<%# LOGO %>
<div class="flex justify-between my-10 mx-3">
  <h1 class="text-5xl font-semibold text-white">SayPay</h1>
  <%= link_to "#", class: "p-3 rounded-full bg-[#21A179] text-white flex items-center justify-center" do %>
  <%# <i data-lucide="ellipsis-vertical"></i> %>
  <i data-lucide="text-align-justify"></i>
  <% end %>
</div>


<%# Container %>
<div class="bg-[#F2FFFB] rounded-t-2xl p-10 flex-grow">
  <h1 class="font-bold text-2xl mb-4">Press to record for your trip in <%= @trip.country %></h1>

  <%= form_with model: [@trip, @expense], id: "recording-form", local: true, html: { multipart: true } do |f| %>
    <div class="space-y-2">
      <div>
        <button type="button" id="start-recording" class="btn rounded-full bg-[#21A179] text-white">Start Recording</button>
        <button type="button" id="stop-recording" class="btn rounded-full bg-gray-400 text-white hidden" disabled>Stop and Send Recording</button>
      </div>


      <div id="recording-status" class="mt-2 text-sm text-gray-700 hidden" aria-live="polite">
        <span id="recording-dot" class="inline-block w-2 h-2 rounded-full bg-red-600 mr-2 hidden" aria-hidden="true"></span>
        <span id="recording-message"></span>
      </div>

      <div>
        <%= f.hidden_field :trip_id, value: @trip.id %>
        <%= f.file_field :audio, id: "expense_audio", accept: "audio/*", class: "hidden" %>
      </div>
    </div>
  <% end %>
</div>

<p class="hello"></p>

<%# yesIn stimulus and JS file! %>
<script>
  document.addEventListener("DOMContentLoaded", () => {
    const startBtn = document.getElementById('start-recording')
    const stopBtn  = document.getElementById('stop-recording')
    const fileInput = document.getElementById('expense_audio')
    const form = document.getElementById('recording-form')

    const statusEl = document.getElementById('recording-status')
    const statusDot = document.getElementById('recording-dot')
    const statusMessage = document.getElementById('recording-message')

    let mediaRecorder = null
    let stream = null
    let chunks = []
    let recordTimer = null
    let warmupTimer = null
    const WARMUP_MS = 800 // short warmup delay (adjust as needed)
    const MAX_MS = 60_000 // 60 seconds

    const mimeCandidates = ['audio/webm;codecs=opus','audio/ogg;codecs=opus','audio/mp4','audio/wav']
    function supportedMime() {
      if (!window.MediaRecorder) return ''
      for (const c of mimeCandidates) {
        try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c } catch(e) {}
      }
      return ''
    }

    function showStatus(msg, showDot = false) {
      statusMessage.textContent = msg
      statusEl.classList.remove('hidden')
      if (showDot) statusDot.classList.remove('hidden')
      else statusDot.classList.add('hidden')
    }

    function hideStatus() {
      statusEl.classList.add('hidden')
      statusDot.classList.add('hidden')
      statusMessage.textContent = ''
    }

    function resetUIAfterStop() {
      // re-enable and reset buttons/UI after form submits or stop
      startBtn.disabled = false
      startBtn.classList.remove('hidden')
      stopBtn.classList.add('hidden')
      stopBtn.disabled = true
      hideStatus()
      chunks = []
    }

    startBtn.addEventListener('click', async (e) => {
      e.preventDefault()
      if (!navigator.mediaDevices || !window.MediaRecorder) return alert('Your browser does not support audio recording')

      // disable to avoid double clicks
      startBtn.disabled = true
      showStatus('Initializing microphone...')

      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true })
      } catch (err) {
        showStatus('Microphone permission required', false)
        startBtn.disabled = false
        return
      }

      // short warmup delay before starting the recording
      showStatus('Preparing... starting soon', false)
      warmupTimer = setTimeout(() => {
        // start real recording after a short warmup
        try {
          const mime = supportedMime()
          mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined)
          chunks = []

          mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data) }
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' })
            chunks = []

            const ext = blob.type.split('/').shift() === 'audio' ? blob.type.split('/').pop().split(';')[0] : 'webm'
            const file = new File([blob], `recording-${Date.now()}.${ext}`, { type: blob.type })
            const dt = new DataTransfer()
            dt.items.add(file)
            fileInput.files = dt.files

            // prevent additional interactions and submit
            stopBtn.disabled = true
            startBtn.disabled = true
            form.submit()
          }

          mediaRecorder.start()
          // UI switch to actual recording state
          startBtn.classList.add('hidden')
          stopBtn.classList.remove('hidden')
          stopBtn.disabled = false
          showStatus('Recording â€” Speak now', true)

          // auto stop after max duration
          recordTimer = setTimeout(() => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
              mediaRecorder.stop()
              showStatus('Recording stopped automatically after 60s', false)
            }
          }, MAX_MS)
        } catch (err) {
          showStatus('Could not start recording: ' + (err.message || err), false)
          startBtn.disabled = false
        }
      }, WARMUP_MS)
    })

    stopBtn.addEventListener('click', (e) => {
      e.preventDefault()
      // if warmup not finished, cancel warmup and reset UI
      if (warmupTimer) {
        clearTimeout(warmupTimer)
        warmupTimer = null
        if (stream) {
          stream.getTracks().forEach(t => t.stop())
          stream = null
        }
        resetUIAfterStop()
        return
      }

      if (recordTimer) {
        clearTimeout(recordTimer)
        recordTimer = null
      }
      if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop()
      if (stream) stream.getTracks().forEach(t => t.stop())
      // reset UI will be handled after submission if form will redirect;
      // If you want immediate reset without navigation, uncomment:
      // resetUIAfterStop()
    })
  })
</script>
