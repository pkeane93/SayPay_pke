<div class="text-center">
  <h1 class="font-bold text-2xl">Press to record</h1>

  <%= form_with model: @recording, id: "recording-form", local: true, html: { multipart: true } do |f| %>
    <div class="space-y-2">
      <div>
        <button type="button" id="start-recording" class="btn bg-[#21A179] text-white">Start Recording</button>
        <button type="button" id="stop-recording" class="btn bg-gray-400 text-white hidden">Stop and Send Recording</button>
      </div>

      <div>
        <%= f.hidden_field :trip_id, value: @trip.id%>
        <%= f.file_field :audio, id: "recording_audio", accept: "audio/*", class: "hidden" %>
      </div>
    </div>  
  <% end %>
</div>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    const startBtn = document.getElementById('start-recording')
    const stopBtn  = document.getElementById('stop-recording')
    const fileInput = document.getElementById('recording_audio')
    const form = document.getElementById('recording-form')

    let mediaRecorder = null
    let stream = null
    let chunks = []
    let recordTimer = null
    const MAX_MS = 60_000 // 60 seconds

    const mimeCandidates = ['audio/webm;codecs=opus','audio/ogg;codecs=opus','audio/mp4','audio/wav']
    function supportedMime() {
      if (!window.MediaRecorder) return ''
      for (const c of mimeCandidates) {
        try { if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) return c } catch(e) {}
      }
      return ''
    }

    startBtn.addEventListener('click', async (e) => {
      e.preventDefault()
      if (!navigator.mediaDevices || !window.MediaRecorder) return alert('Your browser does not support audio recording')

      startBtn.classList.add('hidden')
      stopBtn.classList.remove('hidden')

      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true })
        const mime = supportedMime()
        mediaRecorder = new MediaRecorder(stream, mime ? { mimeType: mime } : undefined)

        mediaRecorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data) }
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: chunks[0]?.type || 'audio/webm' })
          chunks = []

          const ext = blob.type.split('/').shift() === 'audio' ? blob.type.split('/').pop().split(';')[0] : 'webm'
          const file = new File([blob], `recording-${Date.now()}.${ext}`, { type: blob.type })
          const dt = new DataTransfer()
          dt.items.add(file)
          fileInput.files = dt.files

          // prevent additional clicks and submit immediately
          stopBtn.disabled = true
          startBtn.disabled = true
          form.submit()
        }

        mediaRecorder.start()
        recordTimer = setTimeout(() => {
          if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop()
            // optional: show message or UX to let user know it auto-stopped
          }
        }, MAX_MS)
      } catch (err) {
        alert('Microphone permission required: ' + (err.message || err))
        startBtn.classList.remove('hidden')
        stopBtn.classList.add('hidden')
      }
    })

    stopBtn.addEventListener('click', (e) => {
      e.preventDefault()
      if (recordTimer) {
        clearTimeout(recordTimer)
        recordTimer = null
      }
      if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop()
      if (stream) stream.getTracks().forEach(t => t.stop())
    })
  })
</script>
